from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import sapien.pysapien
import sapien.pysapien_pinocchio
import typing
__all__ = ['PhysxArticulation', 'PhysxArticulationJoint', 'PhysxArticulationLinkComponent', 'PhysxBaseComponent', 'PhysxBodyConfig', 'PhysxCollisionShape', 'PhysxCollisionShapeBox', 'PhysxCollisionShapeCapsule', 'PhysxCollisionShapeConvexMesh', 'PhysxCollisionShapeCylinder', 'PhysxCollisionShapePlane', 'PhysxCollisionShapeSphere', 'PhysxCollisionShapeTriangleMesh', 'PhysxContact', 'PhysxContactPoint', 'PhysxCpuSystem', 'PhysxDistanceJointComponent', 'PhysxDriveComponent', 'PhysxEngine', 'PhysxGearComponent', 'PhysxGpuContactBodyImpulseQuery', 'PhysxGpuContactPairImpulseQuery', 'PhysxGpuSystem', 'PhysxJointComponent', 'PhysxMaterial', 'PhysxRayHit', 'PhysxRigidBaseComponent', 'PhysxRigidBodyComponent', 'PhysxRigidDynamicComponent', 'PhysxRigidStaticComponent', 'PhysxSceneConfig', 'PhysxShapeConfig', 'PhysxSystem', 'get_body_config', 'get_default_material', 'get_scene_config', 'get_shape_config', 'is_gpu_enabled', 'set_body_config', 'set_default_material', 'set_gpu_memory_config', 'set_scene_config', 'set_shape_config', 'version']
M = typing.TypeVar("M", bound=int)
class PhysxArticulation:
    name: str
    pose: sapien.pysapien.Pose
    qacc: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]
    qf: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]
    qpos: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]
    qvel: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]
    root_angular_velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]
    root_linear_velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]
    root_pose: sapien.pysapien.Pose
    sleep_threshold: float
    solver_position_iterations: int
    solver_velocity_iterations: int
    @staticmethod
    def create_pinocchio_model(articulation: PhysxArticulation, gravity = [0, 0, -9.81]) -> sapien.pysapien_pinocchio.PinocchioModel:
        ...
    def clone_links(self) -> list[PhysxArticulationLinkComponent]:
        ...
    def compute_passive_force(self, gravity: bool = True, coriolis_and_centrifugal: bool = True) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def create_fixed_tendon(self, link_chain: list[PhysxArticulationLinkComponent], coefficients: list[float], recip_coefficients: list[float], rest_length: float = 0, offset: float = 0, stiffness: float = 0, damping: float = 0, low: float = -3.4028234663852886e+38, high: float = 3.4028234663852886e+38, limit_stiffness: float = 0) -> None:
        ...
    def find_joint_by_name(self, name: str) -> PhysxArticulationJoint:
        ...
    def find_link_by_name(self, name: str) -> PhysxArticulationLinkComponent:
        ...
    def get_active_joints(self) -> list[PhysxArticulationJoint]:
        ...
    def get_dof(self) -> int:
        ...
    def get_gpu_index(self) -> int:
        ...
    def get_joints(self) -> list[PhysxArticulationJoint]:
        ...
    def get_links(self) -> list[PhysxArticulationLinkComponent]:
        ...
    def get_name(self) -> str:
        ...
    def get_pose(self) -> sapien.pysapien.Pose:
        ...
    def get_qacc(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def get_qf(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def get_qlimit(self) -> numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]:
        """
        same as get_qlimit
        """
    def get_qlimits(self) -> numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]:
        ...
    def get_qpos(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def get_qvel(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def get_root(self) -> PhysxArticulationLinkComponent:
        ...
    def get_root_angular_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_root_linear_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_root_pose(self) -> sapien.pysapien.Pose:
        ...
    def get_sleep_threshold(self) -> float:
        ...
    def get_solver_position_iterations(self) -> int:
        ...
    def get_solver_velocity_iterations(self) -> int:
        ...
    def set_name(self, name: str) -> None:
        ...
    def set_pose(self, pose: sapien.pysapien.Pose) -> None:
        ...
    def set_qacc(self, qacc: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    def set_qf(self, qf: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    def set_qpos(self, qpos: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    def set_qvel(self, qvel: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    def set_root_angular_velocity(self, velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple) -> None:
        ...
    def set_root_linear_velocity(self, velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple) -> None:
        ...
    def set_root_pose(self, pose: sapien.pysapien.Pose) -> None:
        ...
    def set_sleep_threshold(self, threshold: float) -> None:
        ...
    def set_solver_position_iterations(self, count: int) -> None:
        ...
    def set_solver_velocity_iterations(self, count: int) -> None:
        ...
    @property
    def active_joints(self) -> list[PhysxArticulationJoint]:
        ...
    @property
    def dof(self) -> int:
        ...
    @property
    def gpu_index(self) -> int:
        ...
    @property
    def joints(self) -> list[PhysxArticulationJoint]:
        ...
    @property
    def links(self) -> list[PhysxArticulationLinkComponent]:
        ...
    @property
    def qlimit(self) -> numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]:
        ...
    @property
    def qlimits(self) -> numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]:
        ...
    @property
    def root(self) -> PhysxArticulationLinkComponent:
        ...
class PhysxArticulationJoint:
    armature: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]
    drive_target: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]
    drive_velocity_target: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]
    friction: float
    limit: numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]
    limits: numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]
    name: str
    pose_in_child: sapien.pysapien.Pose
    pose_in_parent: sapien.pysapien.Pose
    type: typing.Literal['fixed', 'revolute', 'revolute_unwrapped', 'prismatic', 'free']
    def get_armature(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def get_child_link(self) -> PhysxArticulationLinkComponent:
        ...
    def get_damping(self) -> float:
        ...
    def get_dof(self) -> int:
        ...
    def get_drive_mode(self) -> typing.Literal['force', 'acceleration']:
        ...
    def get_drive_target(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def get_drive_velocity_target(self) -> numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]]:
        ...
    def get_force_limit(self) -> float:
        ...
    def get_friction(self) -> float:
        ...
    def get_global_pose(self) -> sapien.pysapien.Pose:
        ...
    def get_limit(self) -> numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]:
        """
        same as get_limits
        """
    def get_limits(self) -> numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]]:
        ...
    def get_name(self) -> str:
        ...
    def get_parent_link(self) -> PhysxArticulationLinkComponent:
        ...
    def get_pose_in_child(self) -> sapien.pysapien.Pose:
        ...
    def get_pose_in_parent(self) -> sapien.pysapien.Pose:
        ...
    def get_stiffness(self) -> float:
        ...
    def get_type(self) -> typing.Literal['fixed', 'revolute', 'revolute_unwrapped', 'prismatic', 'free']:
        ...
    def set_armature(self, armature: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    def set_drive_properties(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        ...
    def set_drive_property(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        """
        same as set_drive_properties
        """
    @typing.overload
    def set_drive_target(self, target: float) -> None:
        ...
    @typing.overload
    def set_drive_target(self, target: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    @typing.overload
    def set_drive_velocity_target(self, velocity: float) -> None:
        ...
    @typing.overload
    def set_drive_velocity_target(self, velocity: numpy.ndarray[tuple[M, typing.Literal[1]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    def set_friction(self, friction: float) -> None:
        ...
    def set_limit(self, limit: numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        """
        same as set_limits
        """
    def set_limits(self, limit: numpy.ndarray[tuple[M, typing.Literal[2]], numpy.dtype[numpy.float32]] | list | tuple) -> None:
        ...
    def set_name(self, name: str) -> None:
        ...
    def set_pose_in_child(self, pose: sapien.pysapien.Pose) -> None:
        ...
    def set_pose_in_parent(self, pose: sapien.pysapien.Pose) -> None:
        ...
    def set_type(self, type: typing.Literal['fixed', 'revolute', 'revolute_unwrapped', 'prismatic', 'free']) -> None:
        ...
    @property
    def child_link(self) -> PhysxArticulationLinkComponent:
        ...
    @property
    def damping(self) -> float:
        ...
    @property
    def dof(self) -> int:
        ...
    @property
    def drive_mode(self) -> typing.Literal['force', 'acceleration']:
        ...
    @property
    def force_limit(self) -> float:
        ...
    @property
    def global_pose(self) -> sapien.pysapien.Pose:
        ...
    @property
    def parent_link(self) -> PhysxArticulationLinkComponent:
        ...
    @property
    def stiffness(self) -> float:
        ...
class PhysxArticulationLinkComponent(PhysxRigidBodyComponent):
    def __init__(self, parent: PhysxArticulationLinkComponent | None = None) -> None:
        ...
    def get_articulation(self) -> PhysxArticulation:
        ...
    def get_children(self) -> list[PhysxArticulationLinkComponent]:
        ...
    def get_gpu_pose_index(self) -> int:
        ...
    def get_index(self) -> int:
        ...
    def get_joint(self) -> PhysxArticulationJoint:
        ...
    def get_parent(self) -> PhysxArticulationLinkComponent:
        ...
    def put_to_sleep(self) -> None:
        ...
    def set_parent(self, parent: PhysxArticulationLinkComponent) -> None:
        ...
    def wake_up(self) -> None:
        ...
    @property
    def articulation(self) -> PhysxArticulation:
        ...
    @property
    def children(self) -> list[PhysxArticulationLinkComponent]:
        ...
    @property
    def gpu_pose_index(self) -> int:
        ...
    @property
    def index(self) -> int:
        ...
    @property
    def is_root(self) -> bool:
        ...
    @property
    def joint(self) -> PhysxArticulationJoint:
        ...
    @property
    def parent(self) -> PhysxArticulationLinkComponent:
        ...
    @property
    def sleeping(self) -> bool:
        ...
class PhysxBaseComponent(sapien.pysapien.Component):
    pass
class PhysxBodyConfig:
    sleep_threshold: float
    solver_position_iterations: int
    solver_velocity_iterations: int
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class PhysxCollisionShape:
    contact_offset: float
    density: float
    local_pose: sapien.pysapien.Pose
    min_patch_radius: float
    patch_radius: float
    physical_material: PhysxMaterial
    rest_offset: float
    def get_collision_groups(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
    @typing.overload
    def get_contact_offset(self) -> float:
        ...
    @typing.overload
    def get_contact_offset(self) -> float:
        ...
    def get_density(self) -> float:
        ...
    def get_local_pose(self) -> sapien.pysapien.Pose:
        ...
    def get_min_patch_radius(self) -> float:
        ...
    def get_patch_radius(self) -> float:
        ...
    def get_physical_material(self) -> PhysxMaterial:
        ...
    @typing.overload
    def get_rest_offset(self) -> float:
        ...
    @typing.overload
    def get_rest_offset(self) -> float:
        ...
    def set_collision_groups(self, groups: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]) -> None:
        """
        collision groups determine the collision behavior of objects. Let A.gx denote the collision group x of collision shape A. Collision shape A and B will collide iff the following condition holds:
        
        ((A.g0 & B.g1) or (A.g1 & B.g0)) and (not ((A.g2 & B.g2) and ((A.g3 & 0xffff) == (B.g3 & 0xffff))))
        
        Here is some explanation: g2 is the "ignore group" and g3 is the "id group". Only the lower 16 bits of the id group is used since the upper 16 bits are reserved for other purposes in the future. When 2 collision shapes have the same ID (g3), then if any of their g2 bits match, their collisions are always ignored.
        
        If after testing g2 and g3, the objects may collide, g0 and g1 come into play. g0 is the "contact type group" and g1 is the "contact affinity group". Collision shapes collide only when a bit in the contact type of the first shape matches a bit in the contact affinity of the second shape.
        """
    @typing.overload
    def set_contact_offset(self, offset: float) -> None:
        ...
    @typing.overload
    def set_contact_offset(self, offset: float) -> None:
        ...
    def set_density(self, density: float) -> None:
        ...
    def set_local_pose(self, pose: sapien.pysapien.Pose) -> None:
        ...
    def set_min_patch_radius(self, radius: float) -> None:
        ...
    def set_patch_radius(self, radius: float) -> None:
        ...
    def set_physical_material(self, material: PhysxMaterial) -> None:
        ...
    @typing.overload
    def set_rest_offset(self, offset: float) -> None:
        ...
    @typing.overload
    def set_rest_offset(self, offset: float) -> None:
        ...
    @property
    def collision_groups(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
class PhysxCollisionShapeBox(PhysxCollisionShape):
    def __init__(self, half_size: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, material: PhysxMaterial) -> None:
        ...
    def get_half_size(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def half_size(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
class PhysxCollisionShapeCapsule(PhysxCollisionShape):
    def __init__(self, radius: float, half_length: float, material: PhysxMaterial) -> None:
        ...
    def get_half_length(self) -> float:
        ...
    def get_radius(self) -> float:
        ...
    @property
    def half_length(self) -> float:
        ...
    @property
    def radius(self) -> float:
        ...
class PhysxCollisionShapeConvexMesh(PhysxCollisionShape):
    @staticmethod
    def load_multiple(filename: str, scale: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, material: PhysxMaterial) -> list[PhysxCollisionShapeConvexMesh]:
        ...
    def __init__(self, filename: str, scale: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, material: PhysxMaterial) -> None:
        ...
    def get_scale(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_triangles(self) -> numpy.ndarray[numpy.uint32[M, 3]]:
        ...
    def get_vertices(self) -> numpy.ndarray[tuple[M, typing.Literal[3]], numpy.dtype[numpy.float32]]:
        ...
    @property
    def scale(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def triangles(self) -> numpy.ndarray[numpy.uint32[M, 3]]:
        ...
    @property
    def vertices(self) -> numpy.ndarray[tuple[M, typing.Literal[3]], numpy.dtype[numpy.float32]]:
        ...
class PhysxCollisionShapeCylinder(PhysxCollisionShape):
    def __init__(self, radius: float, half_length: float, material: PhysxMaterial) -> None:
        ...
    def get_half_length(self) -> float:
        ...
    def get_radius(self) -> float:
        ...
    @property
    def half_length(self) -> float:
        ...
    @property
    def radius(self) -> float:
        ...
class PhysxCollisionShapePlane(PhysxCollisionShape):
    def __init__(self, material: PhysxMaterial) -> None:
        ...
class PhysxCollisionShapeSphere(PhysxCollisionShape):
    def __init__(self, radius: float, material: PhysxMaterial) -> None:
        ...
    def get_radius(self) -> float:
        ...
    @property
    def radius(self) -> float:
        ...
class PhysxCollisionShapeTriangleMesh(PhysxCollisionShape):
    def __init__(self, filename: str, scale: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, material: PhysxMaterial) -> None:
        ...
    def get_scale(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_triangles(self) -> numpy.ndarray[numpy.uint32[M, 3]]:
        ...
    def get_vertices(self) -> numpy.ndarray[tuple[M, typing.Literal[3]], numpy.dtype[numpy.float32]]:
        ...
    @property
    def scale(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def triangles(self) -> numpy.ndarray[numpy.uint32[M, 3]]:
        ...
    @property
    def vertices(self) -> numpy.ndarray[tuple[M, typing.Literal[3]], numpy.dtype[numpy.float32]]:
        ...
class PhysxContact:
    def __repr__(self) -> str:
        ...
    @property
    def bodies(self) -> typing.Annotated[list[PhysxRigidBaseComponent], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def points(self) -> list[PhysxContactPoint]:
        ...
    @property
    def shapes(self) -> typing.Annotated[list[PhysxCollisionShape], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
class PhysxContactPoint:
    @property
    def impulse(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def normal(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def position(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def separation(self) -> float:
        ...
class PhysxCpuSystem(PhysxSystem):
    def __init__(self) -> None:
        ...
    def get_contacts(self) -> list[PhysxContact]:
        ...
    def pack(self) -> bytes:
        ...
    def raycast(self, position: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, direction: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, distance: float) -> PhysxRayHit:
        """
        Casts a ray and returns the closest hit. Returns None if no hit
        """
    def unpack(self, data: bytes) -> None:
        ...
class PhysxDistanceJointComponent(PhysxJointComponent):
    def __init__(self, body: PhysxRigidBodyComponent) -> None:
        ...
    def get_distance(self) -> float:
        ...
    def set_limit(self, low: float, high: float, stiffness: float = 0.0, damping: float = 0.0) -> None:
        ...
    @property
    def distance(self) -> float:
        ...
class PhysxDriveComponent(PhysxJointComponent):
    drive_target: sapien.pysapien.Pose
    def __init__(self, body: PhysxRigidBodyComponent) -> None:
        ...
    def get_drive_property_slerp(self) -> tuple[float, float, float, typing.Literal['force', 'acceleration']]:
        ...
    def get_drive_property_swing(self) -> tuple[float, float, float, typing.Literal['force', 'acceleration']]:
        ...
    def get_drive_property_twist(self) -> tuple[float, float, float, typing.Literal['force', 'acceleration']]:
        ...
    def get_drive_property_x(self) -> tuple[float, float, float, typing.Literal['force', 'acceleration']]:
        ...
    def get_drive_property_y(self) -> tuple[float, float, float, typing.Literal['force', 'acceleration']]:
        ...
    def get_drive_property_z(self) -> tuple[float, float, float, typing.Literal['force', 'acceleration']]:
        ...
    def get_drive_target(self) -> sapien.pysapien.Pose:
        ...
    def get_drive_velocity_target(self) -> tuple[numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]], numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]]:
        ...
    def get_limit_cone(self) -> tuple[float, float, float, float]:
        ...
    def get_limit_pyramid(self) -> tuple[float, float, float, float, float, float]:
        ...
    def get_limit_twist(self) -> tuple[float, float, float, float]:
        ...
    def get_limit_x(self) -> tuple[float, float, float, float]:
        ...
    def get_limit_y(self) -> tuple[float, float, float, float]:
        ...
    def get_limit_z(self) -> tuple[float, float, float, float]:
        ...
    def set_drive_property_slerp(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        ...
    def set_drive_property_swing(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        ...
    def set_drive_property_twist(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        ...
    def set_drive_property_x(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        ...
    def set_drive_property_y(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        ...
    def set_drive_property_z(self, stiffness: float, damping: float, force_limit: float = 3.4028234663852886e+38, mode: typing.Literal['force', 'acceleration'] = 'force') -> None:
        ...
    def set_drive_target(self, target: sapien.pysapien.Pose) -> None:
        ...
    def set_drive_velocity_target(self, linear: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, angular: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple) -> None:
        ...
    def set_limit_cone(self, angle_y: float, angle_z: float, stiffness: float = 0.0, damping: float = 0.0) -> None:
        ...
    def set_limit_pyramid(self, low_y: float, high_y: float, low_z: float, high_z: float, stiffness: float = 0.0, damping: float = 0.0) -> None:
        ...
    def set_limit_twist(self, low: float, high: float, stiffness: float = 0.0, damping: float = 0.0) -> None:
        ...
    def set_limit_x(self, low: float, high: float, stiffness: float = 0.0, damping: float = 0.0) -> None:
        ...
    def set_limit_y(self, low: float, high: float, stiffness: float = 0.0, damping: float = 0.0) -> None:
        ...
    def set_limit_z(self, low: float, high: float, stiffness: float = 0.0, damping: float = 0.0) -> None:
        ...
class PhysxEngine:
    def __init__(self, tolerance_length: float, tolerance_speed: float) -> None:
        ...
class PhysxGearComponent(PhysxJointComponent):
    gear_ratio: float
    def __init__(self, body: PhysxRigidBodyComponent) -> None:
        ...
    def enable_hinges(self) -> None:
        ...
    def get_gear_ratio(self) -> float:
        ...
    def set_gear_ratio(self, ratio: float) -> None:
        ...
    @property
    def is_hinges_enabled(self) -> bool:
        ...
class PhysxGpuContactBodyImpulseQuery:
    @property
    def cuda_impulses(self) -> sapien.pysapien.CudaArray:
        ...
class PhysxGpuContactPairImpulseQuery:
    @property
    def cuda_impulses(self) -> sapien.pysapien.CudaArray:
        ...
class PhysxGpuSystem(PhysxSystem):
    @typing.overload
    def __init__(self, device: str = 'cuda') -> None:
        ...
    @typing.overload
    def __init__(self, device: sapien.pysapien.Device) -> None:
        ...
    def get_scene_offset(self, scene: sapien.pysapien.Scene) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @typing.overload
    def gpu_apply_articulation_qf(self) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_qf(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_qpos(self) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_qpos(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_qvel(self) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_qvel(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_root_pose(self) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_root_pose(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_root_velocity(self) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_root_velocity(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_target_position(self) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_target_position(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_target_velocity(self) -> None:
        ...
    @typing.overload
    def gpu_apply_articulation_target_velocity(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    @typing.overload
    def gpu_apply_rigid_dynamic_data(self) -> None:
        ...
    @typing.overload
    def gpu_apply_rigid_dynamic_data(self, index_buffer: sapien.pysapien.CudaArray) -> None:
        ...
    def gpu_create_contact_body_impulse_query(self, bodies: list[PhysxRigidBaseComponent]) -> PhysxGpuContactBodyImpulseQuery:
        ...
    def gpu_create_contact_pair_impulse_query(self, body_pairs: list[tuple[PhysxRigidBaseComponent, PhysxRigidBaseComponent]]) -> PhysxGpuContactPairImpulseQuery:
        ...
    def gpu_fetch_articulation_link_pose(self) -> None:
        ...
    def gpu_fetch_articulation_link_velocity(self) -> None:
        ...
    def gpu_fetch_articulation_qacc(self) -> None:
        ...
    def gpu_fetch_articulation_qpos(self) -> None:
        ...
    def gpu_fetch_articulation_qvel(self) -> None:
        ...
    def gpu_fetch_articulation_target_qpos(self) -> None:
        ...
    def gpu_fetch_articulation_target_qvel(self) -> None:
        ...
    def gpu_fetch_rigid_dynamic_data(self) -> None:
        ...
    def gpu_init(self) -> None:
        """
           "Warm start" the GPU simulation by stepping the system once. This function
           must be called each time when actors are added or removed from the scene. One
           may call `gpu_apply_*` functions to initialize the system after calling this
           function.
        """
    def gpu_query_contact_body_impulses(self, query: PhysxGpuContactBodyImpulseQuery) -> None:
        """
        Query net contact forces for specific bodies of the last simulation step.
        Usage:
            query = system.gpu_create_contact_body_force_query(bodies)  # create force query in advance
        
            # after simulation step
            system.gpu_query_contact_body_forces(query)
            # query.cuda_buffer is now filled with net contact forces for each body
        """
    def gpu_query_contact_pair_impulses(self, query: PhysxGpuContactPairImpulseQuery) -> None:
        ...
    def gpu_set_cuda_stream(self, stream: int) -> None:
        """
        PhysX GPU APIs will be synchronized with the provided stream and SAPIEN's CUDA
        kernels will be launched to the provided stream.
        
        Args:
            stream: integer representation of a cuda stream pointer
        """
    def gpu_update_articulation_kinematics(self) -> None:
        ...
    def set_scene_offset(self, scene: sapien.pysapien.Scene, offset: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple) -> None:
        """
        In GPU mode, all SAPIEN scenes share the same PhysX scene. One should call this
        function to apply an offset to avoid bodies in different scenes interfere with
        each other. This function must be called before any PhysX body is added to scene.
        
        Example: After calling `set_scene_offset([2, 1, 0])`, an SAPIEN object with
        position `[1, 1, 1]` will be at position `[1, 1, 1] + [2, 1, 0] = [3, 2, 1]` in
        PhysX scene.
        """
    def step_finish(self) -> None:
        ...
    def step_start(self) -> None:
        ...
    def sync_poses_gpu_to_cpu(self) -> None:
        """
        Warning: this function is super slow and for debug only. Download all poses from the GPU and copy to SAPIEN entities.
        """
    @property
    def cuda_articulation_link_data(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_articulation_qacc(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_articulation_qf(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_articulation_qpos(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_articulation_qvel(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_articulation_target_qpos(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_articulation_target_qvel(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_rigid_body_data(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def cuda_rigid_dynamic_data(self) -> sapien.pysapien.CudaArray:
        ...
    @property
    def device(self) -> sapien.pysapien.Device:
        ...
class PhysxJointComponent(PhysxBaseComponent):
    parent: PhysxRigidBaseComponent
    pose_in_child: sapien.pysapien.Pose
    pose_in_parent: sapien.pysapien.Pose
    def get_parent(self) -> PhysxRigidBaseComponent:
        ...
    def get_pose_in_child(self) -> sapien.pysapien.Pose:
        ...
    def get_pose_in_parent(self) -> sapien.pysapien.Pose:
        ...
    def get_relative_pose(self) -> sapien.pysapien.Pose:
        ...
    def set_inv_inertia_scales(self, scale0: float, scale1: float) -> None:
        ...
    def set_inv_mass_scales(self, scale0: float, scale1: float) -> None:
        ...
    def set_parent(self, parent: PhysxRigidBaseComponent) -> None:
        ...
    def set_pose_in_child(self, pose: sapien.pysapien.Pose) -> None:
        ...
    def set_pose_in_parent(self, pose: sapien.pysapien.Pose) -> None:
        ...
    @property
    def relative_pose(self) -> sapien.pysapien.Pose:
        ...
class PhysxMaterial:
    dynamic_friction: float
    restitution: float
    static_friction: float
    def __init__(self, static_friction: float, dynamic_friction: float, restitution: float) -> None:
        ...
    def get_dynamic_friction(self) -> float:
        ...
    def get_restitution(self) -> float:
        ...
    def get_static_friction(self) -> float:
        ...
    def set_dynamic_friction(self, friction: float) -> None:
        ...
    def set_restitution(self, restitution: float) -> None:
        ...
    def set_static_friction(self, friction: float) -> None:
        ...
class PhysxRayHit:
    def __repr__(self) -> str:
        ...
    @property
    def component(self) -> PhysxRigidBaseComponent:
        ...
    @property
    def distance(self) -> float:
        ...
    @property
    def normal(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def position(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def shape(self) -> PhysxCollisionShape:
        ...
class PhysxRigidBaseComponent(PhysxBaseComponent):
    def attach(self, collision_shape: PhysxCollisionShape) -> PhysxRigidBaseComponent:
        ...
    def compute_global_aabb_tight(self) -> numpy.ndarray[tuple[typing.Literal[2], typing.Literal[3]], numpy.dtype[numpy.float32]]:
        ...
    def get_collision_shapes(self) -> list[PhysxCollisionShape]:
        ...
    def get_global_aabb_fast(self) -> numpy.ndarray[tuple[typing.Literal[2], typing.Literal[3]], numpy.dtype[numpy.float32]]:
        ...
    @property
    def _physx_pointer(self) -> int:
        ...
    @property
    def collision_shapes(self) -> list[PhysxCollisionShape]:
        ...
class PhysxRigidBodyComponent(PhysxRigidBaseComponent):
    angular_damping: float
    cmass_local_pose: sapien.pysapien.Pose
    disable_gravity: bool
    inertia: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]
    linear_damping: float
    mass: float
    max_contact_impulse: float
    max_depenetration_velocity: float
    def add_force_at_point(self, force: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, point: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, mode: typing.Literal['force', 'acceleration', 'velocity_change', 'impulse'] = 'force') -> None:
        ...
    def add_force_torque(self, force: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, torque: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple, mode: typing.Literal['force', 'acceleration', 'velocity_change', 'impulse'] = 'force') -> None:
        ...
    def get_angular_damping(self) -> float:
        ...
    def get_angular_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_auto_compute_mass(self) -> bool:
        ...
    def get_cmass_local_pose(self) -> sapien.pysapien.Pose:
        ...
    def get_disable_gravity(self) -> bool:
        ...
    def get_inertia(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_linear_damping(self) -> float:
        ...
    def get_linear_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_mass(self) -> float:
        ...
    def get_max_contact_impulse(self) -> float:
        ...
    def get_max_depenetration_velocity(self) -> float:
        ...
    def set_angular_damping(self, damping: float) -> None:
        ...
    def set_cmass_local_pose(self, pose: sapien.pysapien.Pose) -> None:
        ...
    def set_disable_gravity(self, disable: bool) -> None:
        ...
    def set_inertia(self, inertia: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple) -> None:
        ...
    def set_linear_damping(self, damping: float) -> None:
        ...
    def set_mass(self, mass: float) -> None:
        ...
    def set_max_contact_impulse(self, impulse: float) -> None:
        ...
    def set_max_depenetration_velocity(self, velocity: float) -> None:
        ...
    @property
    def angular_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    @property
    def auto_compute_mass(self) -> bool:
        ...
    @property
    def linear_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
class PhysxRigidDynamicComponent(PhysxRigidBodyComponent):
    angular_velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]
    kinematic: bool
    kinematic_target: sapien.pysapien.Pose
    linear_velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]
    sleep_threshold: float
    solver_position_iterations: int
    solver_velocity_iterations: int
    def __init__(self) -> None:
        ...
    def get_angular_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_gpu_index(self) -> int:
        ...
    def get_gpu_pose_index(self) -> int:
        ...
    def get_kinematic(self) -> bool:
        ...
    def get_kinematic_target(self) -> sapien.pysapien.Pose:
        ...
    def get_linear_velocity(self) -> numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]:
        ...
    def get_locked_motion_axes(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    def get_sleep_threshold(self) -> float:
        ...
    def get_solver_position_iterations(self) -> int:
        ...
    def get_solver_velocity_iterations(self) -> int:
        ...
    def put_to_sleep(self) -> None:
        ...
    def set_angular_velocity(self, velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple) -> None:
        ...
    def set_kinematic(self, kinematic: bool) -> None:
        ...
    def set_kinematic_target(self, target: sapien.pysapien.Pose) -> None:
        ...
    def set_linear_velocity(self, velocity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] | list[float] | tuple) -> None:
        ...
    def set_locked_motion_axes(self, axes: typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(6)]) -> None:
        """
        set some motion axes of the dynamic rigid body to be locked
        Args:
            axes: list of 6 true/false values indicating whether which  of the 6 DOFs of the body is locked.
                  The order is linear X, Y, Z followed by angular X, Y, Z.
        
        Example:
            set_locked_motion_axes([True, False, False, False, True, False]) allows the object to move along the X axis and rotate about the Y axis
        """
    def set_sleep_threshold(self, threshold: float) -> None:
        ...
    def set_solver_position_iterations(self, count: int) -> None:
        ...
    def set_solver_velocity_iterations(self, count: int) -> None:
        ...
    def wake_up(self) -> None:
        ...
    @property
    def gpu_index(self) -> int:
        ...
    @property
    def gpu_pose_index(self) -> int:
        ...
    @property
    def is_sleeping(self) -> bool:
        ...
    @property
    def locked_motion_axes(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
class PhysxRigidStaticComponent(PhysxRigidBaseComponent):
    def __init__(self) -> None:
        ...
class PhysxSceneConfig:
    bounce_threshold: float
    enable_ccd: bool
    enable_enhanced_determinism: bool
    enable_friction_every_iteration: bool
    enable_pcm: bool
    enable_tgs: bool
    gravity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]]
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class PhysxShapeConfig:
    contact_offset: float
    rest_offset: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class PhysxSystem(sapien.pysapien.System):
    scene_collision_id: int
    timestep: float
    def __init__(self) -> None:
        ...
    def get_articulation_link_components(self) -> list[PhysxArticulationLinkComponent]:
        ...
    def get_config(self) -> PhysxSceneConfig:
        ...
    def get_rigid_dynamic_components(self) -> list[PhysxRigidDynamicComponent]:
        ...
    def get_rigid_static_components(self) -> list[PhysxRigidStaticComponent]:
        ...
    def get_scene_collision_id(self) -> int:
        ...
    def get_timestep(self) -> float:
        ...
    def set_scene_collision_id(self, id: int) -> None:
        ...
    def set_timestep(self, timestep: float) -> None:
        ...
    @property
    def articulation_link_components(self) -> list[PhysxArticulationLinkComponent]:
        ...
    @property
    def config(self) -> PhysxSceneConfig:
        ...
    @property
    def rigid_dynamic_components(self) -> list[PhysxRigidDynamicComponent]:
        ...
    @property
    def rigid_static_components(self) -> list[PhysxRigidStaticComponent]:
        ...
def _enable_gpu() -> None:
    ...
def get_body_config() -> PhysxBodyConfig:
    ...
def get_default_material() -> PhysxMaterial:
    ...
def get_scene_config() -> PhysxSceneConfig:
    ...
def get_shape_config() -> PhysxShapeConfig:
    ...
def is_gpu_enabled() -> bool:
    ...
@typing.overload
def set_body_config(solver_position_iterations: int = 10, solver_velocity_iterations: int = 1, sleep_threshold: float = 0.004999999888241291) -> None:
    ...
@typing.overload
def set_body_config(config: PhysxBodyConfig) -> None:
    ...
def set_default_material(static_friction: float, dynamic_friction: float, restitution: float) -> None:
    ...
def set_gpu_memory_config(temp_buffer_capacity: int = 16777216, max_rigid_contact_count: int = 524288, max_rigid_patch_count: int = 81920, heap_capacity: int = 67108864, found_lost_pairs_capacity: int = 262144, found_lost_aggregate_pairs_capacity: int = 1024, total_aggregate_pairs_capacity: int = 1024) -> None:
    ...
@typing.overload
def set_scene_config(gravity: numpy.ndarray[typing.Literal[3], numpy.dtype[numpy.float32]] = ..., bounce_threshold: float = 2.0, enable_pcm: bool = True, enable_tgs: bool = True, enable_ccd: bool = False, enable_enhanced_determinism: bool = False, enable_friction_every_iteration: bool = True, cpu_workers: int = 0) -> None:
    ...
@typing.overload
def set_scene_config(config: PhysxSceneConfig) -> None:
    ...
@typing.overload
def set_shape_config(contact_offset: float = 0.009999999776482582, rest_offset: float = 0.0) -> None:
    ...
@typing.overload
def set_shape_config(config: PhysxShapeConfig) -> None:
    ...
def version() -> str:
    ...
